<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <meta name="description" content="MiniWebGL">
        <style>body, canvas { width: 100%; height: 100%; padding: 0; margin: 0; }</style>
        <script src="../vendor/webgl-debug.js"></script>
        <script src="../dist/mini-webgl.js"></script>
    </head>
    <body>
        <canvas></canvas>
        <script>
            var canvas = document.querySelector('canvas');

            var scene = new MiniWebGL.Scene(canvas);
            var camera = new MiniWebGL.Camera();
            var rootCube = new MiniWebGL.Model(
                new MiniWebGL.Cube(),
                new MiniWebGL.BasicMaterial()
            );
            camera.position.setZ(-20);
            rootCube.position.setZ(-3);
            scene.add(rootCube);

            var gl = scene.renderer.getContext();
            gl.enable( gl.BLEND );
            gl.blendEquation( gl.FUNC_ADD );
            gl.blendFunc( gl.SRC_COLOR, gl.ONE);
            onResize();

            var cubes = [];
            var cubeCount = 200;
            var radius = 8;
            var scale = 3;
            for (let i = 0; i < cubeCount; i++) {
                var pos = i / cubeCount;
                var radiusPos = pos * Math.PI * 2;
                var x = 0 + radius * Math.cos(radiusPos);
                var y = 0 + radius * Math.sin(radiusPos);
                var cube = new MiniWebGL.Model(
                    new MiniWebGL.Cube(),
                    new MiniWebGL.BasicMaterial({
                        color: new MiniWebGL.Math.Vector4(pos, 1 - pos, 1 - pos, 0.5),
                    })
                );
                cube.position.set(x, y, i);
                cube.scale.set(scale, scale, scale);
                rootCube.add(cube);
                cubes.push(cube);
            }
            scene.useCamera(camera);

            var t = performance.now();
            function tick () {
                t = performance.now();
                rootCube.rotation.set(
                    0,
                    (t * 0.0005) % (Math.PI * 2),
                    0
                );

                for (let i = 0; i < cubeCount; i++) {
                    cubes[i].rotation.set(
                        Math.sin(t * 0.0001) + Math.PI,
                        Math.cos(t * 0.0001) + Math.PI,
                        Math.sin(t * 0.001) + Math.PI
                    );
                    var pos = i / cubeCount;
                    var radiusPos = ((pos * Math.PI * 2) + (t * 0.0005)) % (Math.PI * 2);
                    var x = 0 + radius * Math.cos(radiusPos);
                    var y = 0 + radius * Math.sin(radiusPos);
                    cubes[i].position.set(
                        x - Math.sin(y),
                        y*x,
                        Math.abs(0.5 * x + y)
                    );
                }
                scene.render();
                requestAnimationFrame(tick);
            }
            tick();

            window.addEventListener('resize', onResize);

            function updateCanvasDimensions () {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            function onResize () {
                updateCanvasDimensions();
                scene.setSize(canvas.width, canvas.height);
                camera.aspect = canvas.width / canvas.height;
                camera.updateProjectionMatrix();
            }
        </script>
    </body>
</html>
