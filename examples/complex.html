<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <meta name="description" content="MiniWebGL">
        <style>body, canvas { width: 100%; height: 100%; padding: 0; margin: 0; }</style>
        <script src="../vendor/webgl-debug.js"></script>
        <script src="../dist/mini-webgl.js"></script>
    </head>
    <body>
        <canvas></canvas>
        <script>
            var canvas = document.querySelector('canvas');
            updateCanvasDimensions();

            var scene = new MiniWebGL.Scene(canvas);
            var camera = new MiniWebGL.Camera();
            scene.useCamera(camera);
            camera.position[2] = 0;
            camera.updateMatrix();

            // No way to do this in library, add this and
            // make things pretty
            var gl = scene.renderer.getContext();
            gl.enable( gl.BLEND );
            gl.blendEquation( gl.FUNC_ADD );
            gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

            var trianglesPerGroup = 30;
            var groups = 5;
            var triangles = [];

            var radius = 3;
            var triScale = 3.5;
            var GLITCH = false;
            for (var i = 0; i < groups; i++) {
                for (var j = 0; j < trianglesPerGroup; j++) {
                    var triangle = new MiniWebGL.Model(
                        new MiniWebGL.Triangle(),
                        new MiniWebGL.BasicMaterial()
                    );
                    var pos = j / trianglesPerGroup;
                    var radiusPos = pos * Math.PI * 2 * 5;
                    var x = 0 + radius * Math.cos(radiusPos);
                    var y = 0 + radius * Math.sin(radiusPos);
                    triangle.position[0] = (x - (groups/2 * 2) + (i*2))
                    triangle.position[1] = y;
                    triangle.position[2] = (-10 * (1 - pos)) - 5;
                    triangle.material.uniforms.color = new Float32Array([
                        1.1 - pos,
                        pos,
                        (( 1-pos) * 5) - i,
                        0.01
                    ]);
                    triangle.scale = new Float32Array([triScale, triScale, triScale]);
                    triangle.updateMatrix();
                    triangles.push(triangle);
                    scene.add(triangle);
                }
            }

            var t = 0;
            function tick () {
                t++;
                scene.render();

                var osc = (Math.sin(t * 1) + Math.PI) / Math.PI * 2;

                for (let i = 0; i < triangles.length; i++) {
                    var pos = i / triangles.length;
                    var group = Math.floor(i/triangles.length);
                    var x = triangles[i].position[0];
                    var dir = triangles[i].dir;
                    if (dir === undefined) {
                        dir = triangles[i].dir = 1;//x < 0 ? -1 : 1;
                        // dir = triangles[i].dir = x < 0 ? -1 : 1;
                    }

                    if (x > 5) {
                        dir = triangles[i].dir = -1;
                    } else if ( x < -5 ) {
                        dir = triangles[i].dir = 1;
                    }
                    if (GLITCH && (i % 10) === 0) {
                        if (((t) % 3) === 0) {
                            triangles[i].position[0] = Math.random() * 3 * (Math.random() > 0.5 ? -1 : 1);
                            triangles[i].rotation[2] = Math.random() * Math.PI * 2;
                        }
                    } else {
                        triangles[i].position[0] = x + (dir * 0.05);
                    //triangles[i].position[1] = Math.cos(triangles[i].position[2]) * 3;///x + (dir * 0.05);
                    triangles[i].rotation[2] = ((t * 0.01) + (group * 2)) % Math.PI * 2;
                    triangles[i].scale[0] = triangles[i].scale[1] = 
                        Math.abs(x) > 5 ? triScale : ((Math.abs(x/5 * 0.9) + 0.10)* triScale);
                    }
                    // Uniforms cannot yet be updated
                    triangles[i].material.uniforms.color[3] = (Math.sin(t * 1) + Math.PI) / Math.PI * 2;
                    triangles[i].updateMatrix();
                }
                requestAnimationFrame(tick);
            }
            tick();

            window.addEventListener('resize', onResize);

            function updateCanvasDimensions () {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            function onResize () {
                updateCanvasDimensions();
                scene.setSize(canvas.width, canvas.height);
                camera.aspect = canvas.width / canvas.height;
                camera.updateProjectionMatrix();
            }
        </script>
    </body>
</html>
